---
title: Java集合框架
katex: false
tags: java
categories: java
abbrlink: 40254
date: 2021-08-01 14:39:27
---

Java集合框架：List、Set、Map 以及源码解析
<!-- more -->

## Java集合
List、Set、Map都是接口，`List`和`Set`类继承`Collection`接口，`Map`为独立接口
![Iterable](http://whh.plus:7007/images/2021/08/01/java-collection-hierarchy.png)

## List、Set、Map三者区别
- List：存储元素有序、可重复
  - ArrayList(Object[]数组)
    - 优点：底层数据结构是数组，查询快，增删慢
    - 缺点：线程不安全，效率低
  - Vector(Object[]数组)
    - 优点：底层数据结构是数组，查询快，增删慢
    - 缺点：线程安全，效率低
  - LinkedList(双向链表，JDK1.6之前是循环链表，JDK1.7取消了循环)
    - 优点：底层数据结构是链表，查询慢，增删快
    - 缺点：线程不安全，效率高 
- Set：无序、不可重复
  - HashSet(基于HashMap实现) 
    - 底层数据结构是哈希表。(无序唯一)
    - 保证元素唯一性(hashCode()、equals())
  - LinkedHashSet(基于LinkedHashMap实现)
    - 底层数据结构是链表和哈希表。(FIFO插入有序，唯一)
    - 链表保证元素有序
    - 哈希表保证元素唯一 
  - TreeSet(红黑树，自平衡排序二叉树)
    - 底层数据结构是红黑树 (唯一，有序)
    - 元素排序：自然排序，比较器排序
    - 元素唯一性：根据比较的返回值是否为0来决定 
- Map：使用key-value存储。key无序、不可重复；value无序、可重复。一一对应
  - HashMap：JDK1.8之前由数组+链表组成，数组是主体，链表是为解决哈希冲突；JDK1.8之后，在解决哈希冲突时，如果链表长度大于阈值(默认为8)(将链表转换成红黑树前会判断，如果当前数组长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树)时，将链表转换为红黑树，以减少搜索时间
  - LinkedHashMap：LinkedHashMap继承自HashMap，底层仍然基于数组和链表或红黑树组成，增加了一条双向链表，保持键值对的插入顺序。
  - Hashtable：数组+链表组成，数组是Hashtable的主体，链表则是为了解决哈希冲突而存在的
  - TreeMap：红黑树(自平衡的排序二叉树)

## List

### ArrayList
ArrayList的底层是数组队列，相当于动态数组。与Java中的数组相比，它的容量可以动态增长。通过`ensureCapacity`来增加`ArrayList`实例的容量，可以减少递增式再分配的数量

ArrayList继承于AbstractList，实现了List、RandomAcess、Cloneable、java.io.Serializable这些接口
```java
public class ArrayList<E> extends AbstractList<E> implements List<E>,RandomAcess,Cloneable,java.io.Serializable{
}
```

- RandomAcess：表明List集合是支持快速随机访问的。在ArrayList中，即可以通过元素的序号快速获取元素对象。
- Cloneable：覆盖clone()，能被复制
- java.io.Serializable：支持序列化，能通过序列化去传输

### ArrayList源码解析
详见[ArrayList源码](https://whh.plus/2021/08/03/ArrayList)

### LinkedList

### ArrayList 和 Vector 区别
1. ArrayList 是 List的主要实现类，底层使用 Object[]存储，适用频繁的查找工作，线程不安全,用`Collections.synchronizedList`包装ArrayList成一个线程安全的数组容器，原理和Vector一样
2. Vector 是 List的古老实现类，底层使用 Object[]存储。线程安全，对所有方法都加上`synchronized`
### ArrayList 和 LinkedList 区别 
1. 是否保证线程安全：都是不同步的，都不保证线程安全
2. 底层数据结构：ArrayList底层使用的是Object数组；LinkedList底层使用 **双向链表**数据结构(JDK1.6之前为循环链表，JDK1.7取消循环)
3. 插入和删除是否受元素位置的影响：
   - ArrayList采用数组存储，插入和删除元素的时间复杂度受元素位置影响。`add(E e)`时，ArrayList 会默认将元素追加到列表的末尾，时间复杂度为O(1).但如果在指定位置插入和删除的话`add(int index,E element)`时间复杂度为O(n-i).第i位之后的元素都要向后/向前移一位。
   - LinkedList采用链表存储，对于add(E e)插入，删除元素时间复杂度不受元素位置影响，近似O(1)。如果在指定位置插入和删除元素(add(int index,E element))时间复杂度近似为O(n)，需要先移动到指定位置再插入
4. 是否支持快速随机访问：LinkedList不支持高效的随机元素访问，而ArrayList支持。快速随机访问是通过元素的序号快速获取元素对象
5. 内存空间占用：ArrayList的空间浪费主要体现在list列表的结尾会预留一定容量空间。LinkedList的空间花费则体现在每一个元素都需要消耗比ArrayList更多的空间。(需要存放直接后继和直接前驱以及数据)



## 参考
- [Java集合中List,Set以及Map等集合体系详解(史上最全)](https://blog.csdn.net/zhangqunshuai/article/details/80660974)