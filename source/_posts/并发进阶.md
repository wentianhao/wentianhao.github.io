---
title: 并发进阶
katex: false
tags: java
categories: java
abbrlink: 35897
date: 2021-08-11 09:56:24
---
进一步补充并发知识
<!-- more -->
## synchronized 关键字
![synchronized关键字](https://whh.plus/images/synchronized关键字.png)
- `synchronized` 关键字解决多个线程之间访问资源的同步性
- `synchronized` 关键字可以保证被它修饰的方法或代码块在任意时刻只能有一个线程执行

### synchronized 使用
`synchronized`关键字最主要的三种使用方法：
1. 修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
```java
synchronized void method(){
}
```
2. 修饰静态方法：给当前类加锁，会作用于类的所有对象实例，进入同步代码前要获得 **当前class的锁**。因为静态成员不属于任何一个实例对象，是类成员(_static表明这是该类的一个静态资源，不管new了多少个对象，只有一份_)。所以如果线程A调用一个实例对象的非静态`synchronized`方法，而线程B需要调用这个实例对象所属类的静态`synchronized`方法，是允许的，不会发生互斥现象，因为 访问静态`synchronized`方法占用的锁是当前类的锁，而访问非静态`synchronized`方法占用的是当前实例对象锁。

```java
synchronized static void method(){
    // 业务代码
}
```
3. 修饰代码块：指定加锁对象，对给定对象/类加锁
`synchronized(this|object)`：表示进入同步代码前要获得给定对象的锁

`synchronized(类.class)`：表示进入同步代码前要获得当前类的锁

```java
synchronized(this) {
}
```

**小结**
- synchronized 关键字加到static静态方法和synchronized(class)代码块上都是给 Class对象上锁
- synchronized 关键字加到实例方法上是给对象实例上锁。
- synchronized 关键字加到同步方法块，锁的是synchronized括号配置的对象
- 尽量不要使用`synchronized(String a)`因为JVM中，字符串常量池具有缓存功能

**双重校验锁实现对象单例(线程安全)**
```java
public class Singleton{
    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        //先判断对象是否已经实例化，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            // 类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null){
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```
`uniqueInstance` 采用 `volatile` 关键字修饰很有必要，`uniqueInstance = new Singleton()`分为三步执行
1. 为uniqueInstance分配内存空间
2. 初始化uniqueInstance
3. 将uniqueInstance指向分配的内存地址

JVM具有指令重排特性，执行顺序可能会变为1->3->2，指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没初始化的实例。例如，线程T1执行了1 和 3 ，此时 T2 调用getUniqueInstance()发现 uniqueInstance不为空，因此返回uniqueInstance，但是此时uniqueInstance还未被初始化。

**使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行**

**构造方法不能使用synchronized关键字修饰，构造方法本身就是线程安全的，不存在同步构造方法一说**

### 底层原理
synchronized关键字底层原理属于JVM层面

#### synchronized 同步语句块
synchronized同步语句块的实现使用的是monitorenter 和 monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置

当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权，wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。

在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。

在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

#### synchronized 修饰方法
synchronized 修饰的方法并没有 monitorenter 指令和monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

#### 小结
synchronized 同步语句块的实现使用的是 monitorenter和monitorexit指令，其中monitor enter指令指向同步代码块的开始位置，monitor exit指令则指明同步代码块的结束位置。

synchronized 修饰方法时并没有 使用 monitorenter和 monitorexit，而是使用的是 ACC_SYNCHRONIZED 标识，指明了这个方法是一个同步方法

**两者的本质都是 对对象监视器monitor的获取**

### jdk1.6之后优化
JDK1.6之后对锁的实现引入大量优化，如 偏向锁、轻量级锁、自旋锁、适应性锁、锁消除、锁粗化等技术来较少锁操作的开销

锁主要存在四种状态，无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。随着竞争的激烈而不断升级，锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率

### synchronized 和 ReentrantLock 区别
1. 两者都是可重入锁
**可重入锁**：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，这个对象锁还没释放，当其再次想获取这个对象的锁时还是可以获取的，如果不可锁重入的话，会造成死锁。同一个线程每次获取锁，锁的计数器自增1，所以要等到锁的计数器下降为0时才能释放锁

2. synchronized依赖于JVM 而 ReentrantLock 依赖于 API
synchronized是依赖于JVM实现的，优化都是在虚拟机层面，没有暴露给我们

ReentrantLock 是JDK 层面实现的，需要lock()、unlock()方法配合try/finally语句块来完成，可以通过查看源代码，查看实现

3. ReentrantLock比synchronized增加了一些高级功能
- 等待可中断：ReentrantLock提供了一种能够终端等待锁的线程机制，通过lock.lockInterruptibly()来实现这个机制。正在等待的线程可以选择放弃等待，改为处理其他事情
- 可实现公平锁：ReentrantLock可以指定是公平锁还是非公平锁，而synchronized只能是非公平锁。所谓公平锁是先等的线程先获得锁。ReentrantLock默认是非公平的，可以通过ReentrantLock类的`ReentrantLock(boolean fair)`构造方法来指定是否公平
- 可实现选择性通知(锁可以绑定多个条件)：synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需借助Condition接口与newCondition()方法

Condition是JDK1.5之后的，具有很好的灵活性。可以实现多路通知功能，在一个Lock对象中可以创建多个Condition实例(对象监视器)，线程对象可以注册在指定的Condition中，从而有选择性的进行线程通知，在调度线程上更加灵活。

在使用notify()/notifyAll()方法进行通知时，被通知的线程是JVM选择的。

而ReentrantLock类结合Condition实例可以实现“选择性通知”。synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它身上，如果执行notifyAll()方法会通知所有处于等待状态的线程，这样会造成效率问题。而Condition()实例的signalAll()方法只会唤醒注册在该Condition实例中的所有等待线程

## volatile 关键字

### CPU缓存模型
开发网站后台使用的缓存(比如Redis)是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。**CPU缓存则是为了解决CPU处理速度和内存处理速度不对等的问题**

内存可以看作是外存的高速缓存，程序运行的时候，将外存的数据复制到内存，由于内存的处理速度远高于外存，这样就提高了处理速度

小结：CPU Cache 缓存的是内存数据用于解决CPU处理速度和内存不匹配的问题。内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。

**CPU cache的工作方式**
先复制一份数据到CPU Cache中，当CPU需要用到的时候就直接从CPU Cache中读取数据，当运算完成后，再将运算得到的数据写回Main Memory中。但是这样就存在内存缓存不一致的问题！ 比如：执行一个i++操作，两个线程同时执行，假设两个线程从CPU Cache中读取的i=1,两个线程做了1++运算之后再写回Main Memory之后 i = 2.而正确结果应该是i=3

CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议或者其他手段来解决。

### JMM(Java内存模型)
在JDK1.2之前，Java内存模型实现总是从 **主存**(即共享内存)读取变量，是不需要进行特别注意的，而在当前的Java内存模型下，线程可以把变量保存本地内存(比如机器的寄存器)中，而不是直接在主存中进行读写，这就可能造成一个线程在主存中修改了一个变量的值，但另外一个线程还在继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。

要解决这个问题，就需要把变量声明为volatile，这就指示JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

volatile 除了防止JVM指令重排，还有一个作用就是保证变量的可见性

### 并发编程的三个重要特性
1. 原子性：一个操作或者多个操作，要么全部执行并且执行过程不会被任何因素打断，要么就都不执行，原子性就像数据库中的事务一样，它们是一个团队，同生共死。`synchronized`可以保证代码片段的原子性
2. 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。`volatile`保证可见性
3. 有序性：程序执行的顺序按照代码的先后顺序执行。`volatile`保证一定的有序性，另外可以通过synchronized和Lock来保证有序性


### synchronized 和 volatile 区别
- volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字好。但volatile只能修饰变量，而synchronized可以修饰方法和代码块
- volatile保证数据的可见性，但不能保证数据的原子性，而synchronized两者都可保证
- volatile关键字主要用于解决多个线程之间的可见性，而synchronized解决的是多个线程之间访问资源的同步性

## ThreadLocal

### 简介
通常情况下，创建的变量可以被任何一个线程访问并修改。JDK中提供的`ThreadLocal`类是为了解决 **实现每个线程都有自己专属本地变量**

`ThreadLocal`类让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。

如果创建了`ThreadLocal`变量，那么访问这个变量的每个线程都会有这个变量的副本，这也是`ThreadLocal`变量名的由来。使用`get()`和`set()`获取默认值或将其更改为当前线程所存的副本值，避免了线程安全的问题

### demoTest
```java
public class ThreadLocalTest implements Runnable {

    // SimpleDataFormat 不是线程安全的，所以每个线程都要有自己独立的副本
    private static final ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyyMMdd HHmm"));

    public static void main(String[]args) throws InterruptedException {
        ThreadLocalTest obj = new ThreadLocalTest();
        for (int i=0; i< 3; i++) {
            Thread t = new Thread(obj, " " + i);
            Thread.sleep(new Random().nextInt(1000));
            t.start();
        }
    }

    @Override
    public void run() {
        System.out.println("    Thread Name = " + Thread.currentThread().getName() + "  default Formatter = " + formatter.get().toPattern());
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        formatter.set(new SimpleDateFormat());

        System.out.println("    Thread Name= " + Thread.currentThread().getName() +  "  formatter = " +formatter.get().toPattern());
    }
}
```
输出
```bash
Thread Name =  0  default Formatter = yyyyMMdd HHmm
Thread Name=  0  formatter = yy-M-d ah:mm
Thread Name =  1  default Formatter = yyyyMMdd HHmm
Thread Name=  1  formatter = yy-M-d ah:mm
Thread Name =  2  default Formatter = yyyyMMdd HHmm
Thread Name=  2  formatter = yy-M-d ah:mm
```
Thread-0已经改变了formatter的值，但其他线程默认值与初始化值相等。

### ThreadLocal 原理
```java
public class Thread implements Runnable {
    //与此线程有关的ThreadLocal值。由ThreadLocal类维护
    ThreadLocal.ThreadLocalMap threadLocals = null;

    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
    //......
}
```
Thread类有一个threadLocals





## 参考
[JAVA_GUIDE](https://snailclimb.gitee.io/javaguide/#/docs/java/multi-thread/2020%E6%9C%80%E6%96%B0Java%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93)
[Java6及以上版本对synchronized的优化](https://www.cnblogs.com/wuqinglong/p/9945618.html)