<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="先逃跑再说"><meta name="copyright" content="先逃跑再说"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>MySQL学习笔记 | wanheo</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><script src="//at.alicdn.com/t/font_1140697_stqaphw3j4.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js" defer></script><script src="/js/pjax.js" defer></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"wentianhao.github.io","root":"/","title":"先逃跑再说","version":"1.6.1","mode":"time","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"想要搜些什么？","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="wanheo" type="application/atom+xml"><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><meta name="description" content="索引索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有：B树和B+树、Hash 索引优缺点优点：  使用索引可以加快数据检索速度(大大减少索引数据量) 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性  缺点：  创建和维护索引需要耗费许多时间，当对表中数据进行增删改的时候，如果数据有索引，索引也需要动态修改，会降低SQL的执行效率 索引需要物理文件存储，也会耗费一定空间  大多数">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL学习笔记">
<meta property="og:url" content="https://wentianhao.github.io/2021/09/03/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="wanheo">
<meta property="og:description" content="索引索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有：B树和B+树、Hash 索引优缺点优点：  使用索引可以加快数据检索速度(大大减少索引数据量) 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性  缺点：  创建和维护索引需要耗费许多时间，当对表中数据进行增删改的时候，如果数据有索引，索引也需要动态修改，会降低SQL的执行效率 索引需要物理文件存储，也会耗费一定空间  大多数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://whh.plus/images/20210513092328171.png">
<meta property="og:image" content="https://whh.plus/images/20210420165409106.png">
<meta property="og:image" content="https://whh.plus/images/20210420165254215.png">
<meta property="og:image" content="https://whh.plus/images/20210420165311654.png">
<meta property="og:image" content="https://whh.plus/images/20210420165326946.png">
<meta property="og:image" content="https://whh.plus/images/20210420165341868.png">
<meta property="og:image" content="https://whh.plus/imags/01.png">
<meta property="og:image" content="https://whh.plus/imags/02.png">
<meta property="og:image" content="https://whh.plus/imags/03.png">
<meta property="og:image" content="https://whh.plus/imags/04.png">
<meta property="og:image" content="https://whh.plus/imags/05.png">
<meta property="og:image" content="https://whh.plus/imags/06.png">
<meta property="og:image" content="https://whh.plus/imags/07.png">
<meta property="og:image" content="https://whh.plus/imags/09.png">
<meta property="og:image" content="https://whh.plus/imags/10.png">
<meta property="og:image" content="https://whh.plus/imags/11.png">
<meta property="og:image" content="https://whh.plus/imags/12.png">
<meta property="og:image" content="https://whh.plus/imags/13.png">
<meta property="og:image" content="https://whh.plus/imags/14.png">
<meta property="og:image" content="https://whh.plus/imags/03.png">
<meta property="og:image" content="https://whh.plus/imags/15.png">
<meta property="og:image" content="https://whh.plus/imags/16.png">
<meta property="og:image" content="https://whh.plus/imags/17.png">
<meta property="og:image" content="https://whh.plus/imags/18.png">
<meta property="og:image" content="https://whh.plus/imags/19.png">
<meta property="og:image" content="https://whh.plus/imags/20.png">
<meta property="og:image" content="https://whh.plus/imags/21.png">
<meta property="og:image" content="https://whh.plus/imags/22.png">
<meta property="article:published_time" content="2021-09-03T02:03:59.000Z">
<meta property="article:modified_time" content="2021-09-06T08:08:25.011Z">
<meta property="article:author" content="先逃跑再说">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://whh.plus/images/20210513092328171.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><canvas id="trianglifyContainer"></canvas><script defer src="https://cdn.jsdelivr.net/npm/trianglify@4/dist/trianglify.bundle.js"></script><script>document.addEventListener("DOMContentLoaded", () => {
  const pattern = trianglify({
    width: 800,
    height: 600,
    cellSize: 75,
    palette: ["YlGnBu", "GnBu", "Purples", "Blues"],
  });
  const canvasOpts = {
    applyCssScaling: false
  }
  document.body.appendChild(pattern.toCanvas(trianglifyContainer, canvasOpts));
});</script><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info mickey-mouse"><a class="site-author-avatar" href="/about/" title="先逃跑再说"><img width="96" loading="lazy" src="/images/wen.jpg" alt="先逃跑再说"><span class="site-author-status" title="永远相信美好的事情即将发生">😊</span></a><div class="site-author-name"><a href="/about/">先逃跑再说</a></div><a class="site-name" href="/about/site.html">wanheo</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="我的主页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">87</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">28</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">35</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/wentianhao" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=286380463" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="1024008684@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">索引类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-Primary-Key"><span class="toc-number">2.1.</span> <span class="toc-text">主键索引(Primary Key)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95-%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="toc-number">2.2.</span> <span class="toc-text">二级索引(辅助索引)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">3.</span> <span class="toc-text">聚集索引和非聚集索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">3.1.</span> <span class="toc-text">聚集索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">3.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.</span> <span class="toc-text">非聚集索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">4.</span> <span class="toc-text">非聚集索引一定回表查询吗？(覆盖索引)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">5.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.</span> <span class="toc-text">创建索引的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE"><span class="toc-number">7.</span> <span class="toc-text">使用索引的一些建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%A6%82%E4%BD%95%E4%B8%BA%E5%AD%97%E6%AE%B5%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">8.</span> <span class="toc-text">MySQL如何为字段添加索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%97%A5%E5%BF%97"><span class="toc-number">9.</span> <span class="toc-text">MySQL日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo-log"><span class="toc-number">10.</span> <span class="toc-text">redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-number">10.1.</span> <span class="toc-text">redo log 刷盘时机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#innodb-flush-log-at-trx-commit-0"><span class="toc-number">10.1.1.</span> <span class="toc-text">innodb_flush_log_at_trx_commit&#x3D;0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#innodb-flush-log-at-trx-commit-1"><span class="toc-number">10.1.2.</span> <span class="toc-text">innodb_flush_log_at_trx_commit&#x3D;1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#innodb-flush-log-at-trx-commit-2"><span class="toc-number">10.1.3.</span> <span class="toc-text">innodb_flush_log_at_trx_commit&#x3D;2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84"><span class="toc-number">10.2.</span> <span class="toc-text">日志文件组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-%E5%B0%8F%E7%BB%93"><span class="toc-number">10.3.</span> <span class="toc-text">redo log 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binlog"><span class="toc-number">11.</span> <span class="toc-text">binlog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">记录格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">11.2.</span> <span class="toc-text">写入机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">12.</span> <span class="toc-text">两阶段提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undo-log"><span class="toc-number">13.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">14.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://wentianhao.github.io/2021/09/03/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="先逃跑再说"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="wanheo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">MySQL学习笔记<a class="post-edit-link" href="https://github.com/wentianhao/wentianhao.github.io/tree/hexo/source/_posts/MySQL学习笔记.md" target="_blank" title="编辑" rel="noopener"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-edit-line"></use></svg></a></h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-09-03 10:03:59" itemprop="dateCreated datePublished" datetime="2021-09-03T10:03:59+08:00">2021-09-03</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-09-06 16:08:25" itemprop="dateModified" datetime="2021-09-06T16:08:25+08:00">2021-09-06</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">6.3k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">22m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/mysql/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">mysql</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/mysql/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">mysql</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有：B树和B+树、Hash</p>
<p><strong>索引优缺点</strong><br>优点：</p>
<ul>
<li>使用索引可以加快数据检索速度(大大减少索引数据量)</li>
<li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性</li>
</ul>
<p>缺点：</p>
<ul>
<li>创建和维护索引需要耗费许多时间，当对表中数据进行增删改的时候，如果数据有索引，索引也需要动态修改，会降低SQL的执行效率</li>
<li>索引需要物理文件存储，也会耗费一定空间</li>
</ul>
<p>大多数情况下，索引查询比全表扫描快，如果数据库的数据量不大，使用索引不一定能带来很大的提升。</p>
<p><strong>索引的底层数据结构</strong><br><strong>Hash表</strong><br>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据(接近O(1))</p>
<p>哈希算法，可以快速找到value对应的index,找到index也就找到对应的value。</p>
<pre class="language-java" data-language="java"><code class="language-java">hash <span class="token operator">=</span> <span class="token function">hashfunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
index <span class="token operator">=</span> hash <span class="token operator">%</span> array_size</code></pre>
<p><img src="https://whh.plus/images/20210513092328171.png" alt="hash" loading="lazy"></p>
<p>哈希算法有hash冲突问题，多个key最后可能得到相同的index。通常解决办法是链地址法。链地址法是将哈希冲突数据存放在链表中。比如HashMap，就是通过链地址法解决冲突的。</p>
<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p>
<p><strong>为什么Mysql没有使用哈希表作索引的数据结构呢</strong>？</p>
<ol>
<li>哈希冲突问题</li>
<li>哈希索引不支持顺序和范围查询：hash索引不支持顺序和范围查询是最大的缺点。</li>
</ol>
<p><strong>B树和 B+树</strong><br>B树也叫B-树，全称是多路平衡查找树，B+树是B树的一种变体。B树和B+树种的B是balance的意思</p>
<p><strong>目前大部分数据库系统及文件系统都采用B树或B+树作为索引结构</strong></p>
<p>B树 B+树</p>
<ul>
<li>B树的所有节点既存放key也存放data，而b+树所有的非叶子节点只存放key,叶子节点存放key和data</li>
<li>B树的所有叶子节点都是独立的，B+树的叶子节点有一条引用链指向相邻的叶子节点</li>
<li>B树的检索过程相当于对范围内的每个节点的关键字作二分查找，可能没有到叶子节点就检索结束，而B+树检索效率稳定，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显<br><img src="https://whh.plus/images/20210420165409106.png" alt="20210420165409106.png" loading="lazy"></li>
</ul>
<p>在MySQL中，MYISAM引擎和InnoDB引擎都是使用B+树作为索引结构，但是，两者实现方式不太一样。</p>
<p>MyISAM引擎中，B+树叶节点的data域存放的是数据的地址，在检索时，首先按照B+树搜索算法搜索引擎，如果指定的key存在，取出其data域的值，然后以data域的值作为地址读取对应的数据记录。 <strong>非聚簇索引</strong></p>
<p>InnoDB引擎中，其数据文件本身就是索引文件。树的叶节点data域保存了完整的数据记录。<strong>聚簇索引</strong> 。如果这个索引的 key 是数据表的主键，主键索引。其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h3><p>数据表的主键列使用的就是主键索引</p>
<p>一张表只能有一个主键，并且主键不能为null，不能重复</p>
<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>
<h3 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h3><p>二级索引又称辅助索引，因为二级索引的叶子节点存储的数据是主键。通过二级索引，可以定位主键的位置。</p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<ul>
<li><strong>唯一索引</strong>：唯一索引也是一种约束。唯一索引的属性列不能出现重复值，但允许数据为NULL,一张表允许创建多个唯一索引。建立唯一索引的目的大部分时候是为了该属性列的数据的唯一性，而不是为了查询效率</li>
<li><strong>普通索引</strong>：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。</li>
<li><strong>前缀索引</strong>：前缀索引只使用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符</li>
<li><strong>全文索引</strong>：全文索引主要是为了减速哦大文本数据中的关键字的信息。是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ul>
<p><strong>二级索引</strong><br><img src="https://whh.plus/images/20210420165254215.png" alt="二级索引" loading="lazy"></p>
<h2 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h2><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>聚集索引即索引结构和数据存放在一起的索引。主键索引属于聚集索引</p>
<p>Mysql中，InnoDB引擎中，.ibd文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引的每个非叶子节点存储索引，叶子节点存储索引和对应的数据</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>聚集索引的查询速度非常快，因为B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>依赖有序的数据：B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入的时排序，如果数据是整型还好，如果是是类似字符串或UUID这种又长又难比较的数据，插入和查找的速度肯定比较慢</li>
<li>更新代价大： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
<h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>非聚集索引就是索引结构和数据分开存放的索引</p>
<p>二级索引属于非聚集索引</p>
<p>MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p>
<p>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>更新代价比聚集索引更小。非聚集索引的更新代价没有聚集索引大，非聚集索引的叶子节点是不存放数据的。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>跟聚集索一样，非聚集索引也依赖于有序数据</li>
<li>可能会二次查询(回表)：也是非聚集索引最大的缺点。当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</li>
</ol>
<p><img src="https://whh.plus/images/20210420165311654.png" alt="20210420165311654.png" loading="lazy"></p>
<p>聚集索引和非聚集索引<br><img src="https://whh.plus/images/20210420165326946.png" alt="20210420165326946.png" loading="lazy"></p>
<h2 id="非聚集索引一定回表查询吗？-覆盖索引"><a href="#非聚集索引一定回表查询吗？-覆盖索引" class="headerlink" title="非聚集索引一定回表查询吗？(覆盖索引)"></a>非聚集索引一定回表查询吗？(覆盖索引)</h2><p>不一定回表查询。</p>
<p>用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">'ww'</span><span class="token punctuation">;</span></code></pre>

<p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>
<p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢?</p>
<p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果一个索引包含(或者说覆盖)所有需要查询的字段的值，则称之为覆盖索引。</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据， 而无需回表查询。</strong></p>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p>
<p><img src="https://whh.plus/images/20210420165341868.png" alt="20210420165341868.png" loading="lazy"></p>
<h2 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h2><ol>
<li>选择合适的字段创建索引</li>
</ol>
<ul>
<li>不为 NULL 的字段 ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li>被频繁查询的字段 ：我们创建索引的字段应该是查询操作非常频繁的字段</li>
<li>被作为条件查询的字段 ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li>频繁需要排序的字段 ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li>被经常频繁用于连接的字段 ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率</li>
</ul>
<ol start="2">
<li>被频繁更新的字段应该慎重建立索引。<br>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</li>
<li>尽可能的考虑建立联合索引而不是单列索引。<br>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</li>
<li>注意避免冗余索引<br>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</li>
<li>考虑在字符串类型的字段上使用前缀索引代替普通索引。<br>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</li>
</ol>
<h2 id="使用索引的一些建议"><a href="#使用索引的一些建议" class="headerlink" title="使用索引的一些建议"></a>使用索引的一些建议</h2><ul>
<li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li>
<li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li>
<li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li>
<li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li>
</ul>
<h2 id="MySQL如何为字段添加索引"><a href="#MySQL如何为字段添加索引" class="headerlink" title="MySQL如何为字段添加索引"></a>MySQL如何为字段添加索引</h2><ol>
<li>添加主键索引(primary key)<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token string">'table_name'</span> <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token string">'column'</span><span class="token punctuation">)</span></code></pre></li>
<li>添加UNIQUE(唯一索引)<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token string">'table_name'</span> <span class="token keyword">ADD</span> <span class="token keyword">UNIQUE</span> <span class="token punctuation">(</span><span class="token string">'column'</span><span class="token punctuation">)</span></code></pre></li>
<li>添加index(普通索引)<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token string">'table_name'</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name<span class="token punctuation">(</span><span class="token string">'column'</span><span class="token punctuation">)</span></code></pre></li>
<li>添加FULLTEXT(全文索引)<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>table_name<span class="token punctuation">`</span> <span class="token keyword">ADD</span> FULLTEXT <span class="token punctuation">(</span> <span class="token punctuation">`</span><span class="token keyword">column</span><span class="token punctuation">`</span><span class="token punctuation">)</span></code></pre></li>
<li>添加多列索引<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token string">'table_name'</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name<span class="token punctuation">(</span><span class="token string">'column1'</span><span class="token punctuation">,</span><span class="token string">'column2'</span><span class="token punctuation">)</span></code></pre></li>
</ol>
<h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><p>MySQL日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志等几大类。其中，比较重要的是二进制日志binlog(归档日志) 和 事务日志 redo log(重做日志) 和 undo log(回滚日志)<br><img src="https://whh.plus/imags/01.png" alt="01.png" loading="lazy"></p>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>重做日志是InnoDB存储引擎独有的，让MySQL拥有崩溃恢复的能力。</p>
<p>比如MySQL实例挂了或者宕机了，重启时，InnoDB存储引擎会使用redo log 恢复数据，保证数据的持久性和完整性<br><img src="https://whh.plus/imags/02.png" alt="02.png" loading="lazy"></p>
<p>MySQL中的数据是以页为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫做数据页，会放入到Buffer Pool中。后续的查询都是从Buffer Pool中找，没有命中再去硬盘加载，减少硬盘IO开销，提升性能。更新表数据的时候，也是这样，发现在buffer Pool中存在，就直接在buffer Pool中更新数据。然后会把“在某个数据页做了什么修改”记录到重做日志缓存(redo log buffer)中，接着就刷盘到redo log文件里<br><img src="https://whh.plus/imags/03.png" alt="03.png" loading="lazy"></p>
<p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p>
<p>每条redo记录：表空间号 + 数据页号 + 偏移量 + 修改数据长度 + 具体修改的数据  组成</p>
<h3 id="redo-log-刷盘时机"><a href="#redo-log-刷盘时机" class="headerlink" title="redo log 刷盘时机"></a>redo log 刷盘时机</h3><p>InnoDB存储引擎为redo log 的刷盘策略提供了innodb_flush_log_at_trx_commit 参数，提供三种策略：</p>
<ul>
<li>0 ：设置为0的时候，表示每次事务提交时不进行刷盘操作</li>
<li>1 ：设置为1的时候，表示每次事务提交时进行刷盘操作(默认值)</li>
<li>2 ：设置为2的时候，表示每次事务提交时将redo log buffer内容写入文件系统缓存 page cache 中</li>
</ul>
<p>innodb_flush_log_at_trx_commit 参数默认值为1，也就是事务提交时调用fsync对redo log 进行刷盘。</p>
<p>InnoDB存储引擎有一个后台线程，每隔1s,就会把redo log buffer中的内容写到文件系统缓存(page cache)，然后调用fsync刷盘。<br><img src="https://whh.plus/imags/04.png" alt="04.png" loading="lazy"></p>
<p>也就是说，一个没有提交事务的redo log记录，也可能会刷盘。</p>
<p>事务在执行过程中记录会写入redo log buffer,然后是会被后台线程刷盘<br><img src="https://whh.plus/imags/05.png" alt="05.png" loading="lazy"></p>
<p>除了后台线程每秒1次的轮询操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。</p>
<h4 id="innodb-flush-log-at-trx-commit-0"><a href="#innodb-flush-log-at-trx-commit-0" class="headerlink" title="innodb_flush_log_at_trx_commit=0"></a>innodb_flush_log_at_trx_commit=0</h4><p><img src="https://whh.plus/imags/06.png" alt="06.png" loading="lazy"><br>为0时，如果MySQL挂了或者宕机了，可能会有1s的数据丢失</p>
<h4 id="innodb-flush-log-at-trx-commit-1"><a href="#innodb-flush-log-at-trx-commit-1" class="headerlink" title="innodb_flush_log_at_trx_commit=1"></a>innodb_flush_log_at_trx_commit=1</h4><p><img src="https://whh.plus/imags/07.png" alt="07.png" loading="lazy"><br>为1时，只要事务提交成功，redo log记录就一定在硬盘里，不会任何数据丢失。如果事务执行期间，MySQL挂了或者宕机，这部分日志丢了，事务没有提交，不会有损失</p>
<h4 id="innodb-flush-log-at-trx-commit-2"><a href="#innodb-flush-log-at-trx-commit-2" class="headerlink" title="innodb_flush_log_at_trx_commit=2"></a>innodb_flush_log_at_trx_commit=2</h4><p><img src="https://whh.plus/imags/09.png" alt="09.png" loading="lazy"><br>为2时，只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（page cache）。仅仅只是MySQL挂了不会有任何数据丢失，如果宕机了，可能会有1s的数据丢失</p>
<h3 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h3><p>硬盘上存储的redo log 日志文件不只一个，而是以一个日志文件组的形式出现，每个redo的日志文件大小都一样。采用的是环形数组形式，从头开始写，写到末尾又回头循环写。<br><img src="https://whh.plus/imags/10.png" alt="10.png" loading="lazy"></p>
<p>在个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</p>
<ul>
<li>write pos：当前记录位置，一边写一边后移</li>
<li>checkpoint：当前擦除位置，也是往后推移</li>
</ul>
<p>每次刷盘redo log记录到日志文件组中，write pos位置就会后移更新</p>
<p>每次MySQL加载日志文件组恢复数据时，会情况加载过的redo log记录，并把checkpoint后移更新</p>
<p>write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。<br><img src="https://whh.plus/imags/11.png" alt="11.png" loading="lazy"></p>
<p>如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。<br><img src="https://whh.plus/imags/12.png" alt="12.png" loading="lazy"></p>
<h3 id="redo-log-小结"><a href="#redo-log-小结" class="headerlink" title="redo log 小结"></a>redo log 小结</h3><p>思考一个问题： 只要每次把修改后的数据页直接刷盘不就好了，还有 redo log 什么事？</p>
<p>数据页大小是16KB，刷盘比较耗时，可能就修改了数据页里的几 Byte 数据，有必要把完整的数据页刷盘吗？</p>
<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>
<p>如果是写 redo log，一行记录可能就占几十 Byte，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</p>
<p>所以用 redo log 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>redo log是物理日志，记录内容是在某个数据页上做了什么修改，属于InnoDB存储引擎。</p>
<p>而binlog是逻辑日志，记录内容是语句的原始逻辑，类似于“给ID=2这一行的c字段加1”.属于MySQL server层。</p>
<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。<br><img src="https://whh.plus/imags/13.png" alt="13.png" loading="lazy"><br>binlog会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>
<h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><p>三种格式，可通过binlog_format参数指定</p>
<ul>
<li>statement</li>
<li>row</li>
<li>mixed<br>指定statement，记录的内容是SQL语句原文。比如执行一条update T set update_time=now() where id=1，记录的内容如下。<br><img src="https://whh.plus/imags/14.png" alt="14.png" loading="lazy"><br>同步数据时，会执行的sql语句，update_time = now()会获取当前系统时间，直接执行会导致与原库的数据不一致。为了解决这个问题，需要指定为row，记录的内容不再是简单的sql语句，还包含操作的具体数据，记录如下：<br><img src="https://whh.plus/imags/03.png" alt="03.png" loading="lazy"><br>row格式记录的内容看不到详细信息，要通过mysqlbinlog工具解析出来。update_time=now()变成了具体的时间update_time=1627112756247，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（假设这张表只有 3 个字段）。这样就能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。所以就有了一种折中的方案，指定为mixed，记录的内容是前两者的混合。MySQL会判断这条SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式。</li>
</ul>
<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p>binlog的写入时机很简单，事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。可以通过binlog_cache_size参数控制单个线程binlog cache大小，如果存储内容超过了这个参数，就要暂存到硬盘(swap)</p>
<p>binlog日志刷盘流程如下：<br><img src="https://whh.plus/imags/15.png" alt="15.png" loading="lazy"></p>
<ul>
<li>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</li>
<li>上图的 fsync，才是将数据持久化到磁盘的操作</li>
</ul>
<p>write和fsync的时机，可以由参数sync_binlog控制，默认是0。</p>
<p>为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。<br><img src="https://whh.plus/imags/16.png" alt="16.png" loading="lazy"></p>
<p>虽然性能得到提升，但是机器宕机，page cache里面的 binglog 会丢失。为了安全起见，可以设置为1，表示每次提交事务都会执行fsync，就如同binlog 日志刷盘流程一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。<br><img src="https://whh.plus/imags/17.png" alt="17.png" loading="lazy"></p>
<p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>redo log 重做日志让InnoDB存储引擎有了崩溃恢复的能力</p>
<p>binlog 归档日志 保证了MySQL集群架构的数据一致性</p>
<p>虽然都是持久化的保证，但重点不同</p>
<p>在执行更新语句过程，会记录redolog 和 binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只在提交事务时写入，所以redo log与binlog的写入时机不一样。<br><img src="https://whh.plus/imags/18.png" alt="18.png" loading="lazy"></p>
<p>如果 redo log 和binlog两份日志的逻辑不一致，会出现什么问题？</p>
<p>以update语句为例，假设id=2的记录，字段c值是0，把字段c值更新成1，SQL语句为<code>update T set c = 1 where id = 2</code>.</p>
<p>假设执行过程中，写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况？<br><img src="https://whh.plus/imags/19.png" alt="19.png" loading="lazy"></p>
<p>由于binlog没写完就异常，所以binlog没有对应的修改记录，因此，之后用binlog日志恢复数据时，就会少一次更新，恢复出来的这一行c值为0，而原库因为redo log日志恢复，这一行c值为1，最终数据不一致。<br><img src="https://whh.plus/imags/20.png" alt="20.png" loading="lazy"></p>
<p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用两阶段提交方案。将redo log的写入拆成了两个步骤prepare和commit，这就是两阶段提交。<br><img src="https://whh.plus/imags/21.png" alt="21.png" loading="lazy"></p>
<p>使用两阶段提交后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。<br><img src="https://whh.plus/imags/22.png" alt="22.png" loading="lazy"></p>
<p>redo log设置commit阶段发生异常，那会不会回滚事务呢？</p>
<p>不会，会直接提交事务恢复数据。</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>要想保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚，在MySQL中，恢复机制是通过回滚日志undo log实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作，如果执行过程中遇到异常的话，直接利用回滚日志中的信息将数据回滚到修改之前的样子即可。并且，回滚日志会先于数据持久化到磁盘上，这样就保证即使数据库突然宕机，当用户再次启动数据库时，数据库还能够通过查询回滚日志来回滚将之前未完成的事务</p>
<p>MVCC 的实现依赖于：隐藏字段、Read View、undo log。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redo log 保证事务的持久性，undo log 保证事务的原子性，binlog保证数据库的数据的一致性，MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"></div><div style="display:inline-block"></div><div style="display:inline-block"></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>先逃跑再说</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://wentianhao.github.io/2021/09/03/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySQL学习笔记">https://wentianhao.github.io/2021/09/03/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/09/08/%E9%9D%A2%E7%BB%8F/" rel="prev" title="面经"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">面经</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/09/01/MySQL/" rel="next" title="MySQL"><span class="post-nav-text">MySQL</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br></div><div class="toggle-comment-system" style="margin: 1rem auto"><a class="toggle-comment-btn hty-button hty-button--raised text-uppercase" data-target="#valine-container" onclick="showComment(this.dataset.target)">valine</a><style>.utterances {
  display: none;
}</style><a class="toggle-comment-btn hty-button hty-button--raised text-uppercase" data-target=".utterances" onclick="showComment(this.dataset.target)">utterances</a><script>function hideAllComment() {
  //- hide all
  document.querySelectorAll('.toggle-comment-btn').forEach((btn) => {
    const container = document.querySelector(btn.dataset.target);
    if (container) {
      container.style.display = "none";
    }
  });
}
function showComment(target) {
  hideAllComment();
  //- show target
  const targetContainer = document.querySelector(target);
  if (targetContainer) {
    targetContainer.style.display = "block";
  }
}
</script></div><div id="valine-container"></div><script>Yun.utils.getScript("https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js", () => {
  const valineConfig = {"enable":true,"appId":"lKhR0buRT7OeiwUq9ECRwPba-MdYXbMMI","appKey":"5cz28s0hMEfyou89engEFMmS","placeholder":"Just go go","avatar":null,"pageSize":10,"visitor":false,"highlight":true,"recordIP":false,"enableQQ":true,"meta":["nick","mail","link"],"el":"#valine-container","lang":"zh-cn"}
  valineConfig.path = "/2021/09/03/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
  new Valine(valineConfig)
}, window.Valine);</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2020 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 先逃跑再说</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.6.1</span></div><div class="live_time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2020-01-05T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="总访客量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="总访问量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script>const date = new Date();
const today = (date.getMonth() + 1) + "-" + date.getDate()
const mourn_days = ["4-4","9-18"]
if (mourn_days.includes(today)) {
  document.documentElement.style.filter = "grayscale(1)";
}</script></div></body></html>